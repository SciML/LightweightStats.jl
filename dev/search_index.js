var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Module","page":"API Reference","title":"Module","text":"","category":"section"},{"location":"api/#Central-Tendency-Functions","page":"API Reference","title":"Central Tendency Functions","text":"","category":"section"},{"location":"api/#Dispersion-Functions","page":"API Reference","title":"Dispersion Functions","text":"","category":"section"},{"location":"api/#Correlation-and-Covariance","page":"API Reference","title":"Correlation and Covariance","text":"","category":"section"},{"location":"api/#Quantiles","page":"API Reference","title":"Quantiles","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#LightweightStats.LightweightStats","page":"API Reference","title":"LightweightStats.LightweightStats","text":"LightweightStats\n\nA lightweight Julia package providing basic statistical functions with zero dependencies.\n\nThis package offers drop-in replacements for the most commonly used functions from Statistics.jl, but without any dependencies beyond Julia's standard library. It's ideal for projects that need basic statistical operations while minimizing their dependency footprint.\n\nExported Functions\n\nmean - Compute arithmetic mean\nmedian - Compute median value\nstd - Compute standard deviation  \nvar - Compute variance\ncov - Compute covariance\ncor - Compute correlation\nquantile - Compute quantiles\nmiddle - Compute middle of a range\n\nExamples\n\nusing LightweightStats\n\nx = [1, 2, 3, 4, 5]\nmean(x)      # 3.0\nstd(x)       # 1.5811388300841898\nmedian(x)    # 3\n\n\n\n\n\n","category":"module"},{"location":"api/#LightweightStats.mean","page":"API Reference","title":"LightweightStats.mean","text":"mean(A::AbstractArray; dims=:)\n\nCompute the arithmetic mean of array A.\n\nArguments\n\nA::AbstractArray: Input array\ndims=:: Dimensions along which to compute the mean. \n: (default) computes mean of entire array\nInteger or tuple specifies dimensions\n\nReturns\n\nScalar mean when dims=:\nArray of means along specified dimensions otherwise\n\nExamples\n\njulia> using LightweightStats\n\njulia> mean([1, 2, 3, 4, 5])\n3.0\n\njulia> mean([1 2 3; 4 5 6])\n3.5\n\njulia> mean([1 2 3; 4 5 6]; dims=1)\n1×3 Matrix{Float64}:\n 2.5  3.5  4.5\n\njulia> mean([1 2 3; 4 5 6]; dims=2)\n2×1 Matrix{Float64}:\n 2.0\n 5.0\n\nErrors\n\nThrows ArgumentError if array is empty.\n\n\n\n\n\nmean(f, A::AbstractArray)\n\nApply function f to each element of A and compute the mean of the results.\n\nArguments\n\nf: Function to apply to each element\nA::AbstractArray: Input array\n\nReturns\n\nMean of f applied to elements of A\n\nExamples\n\njulia> using LightweightStats\n\njulia> mean(x -> x^2, [1, 2, 3])\n4.666666666666667\n\njulia> mean(abs, [-1, 0, 1])\n0.6666666666666666\n\nErrors\n\nThrows ArgumentError if array is empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.median","page":"API Reference","title":"LightweightStats.median","text":"median(v::Vector)\n\nCompute the median of vector v.\n\nThe median is the middle value when the data is sorted. For even-length vectors, returns the average of the two middle values.\n\nNote: This function is restricted to Vector type for performance reasons as it uses scalar indexing.\n\nArguments\n\nv::Vector: Input vector\n\nReturns\n\nThe median value\n\nExamples\n\njulia> using LightweightStats\n\njulia> median([1, 2, 3, 4, 5])\n3\n\njulia> median([1, 2, 3, 4])\n2.5\n\njulia> median([3, 1, 2])\n2\n\nErrors\n\nThrows ArgumentError if vector is empty.\n\n\n\n\n\nmedian(A::Array; dims=:)\n\nCompute the median of array A, optionally along specified dimensions.\n\nNote: This function is restricted to Array type for performance reasons as it uses scalar indexing.\n\nArguments\n\nA::Array: Input array\ndims=:: Dimensions along which to compute median\n: (default) computes median of entire array\nInteger or tuple specifies dimensions\n\nReturns\n\nScalar median when dims=:\nArray of medians along specified dimensions otherwise\n\nExamples\n\njulia> using LightweightStats\n\njulia> median([1 2 3; 4 5 6])\n3.5\n\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> median(A; dims=1)\n1×3 Matrix{Float64}:\n 2.5  3.5  4.5\n\njulia> median(A; dims=2)\n2×1 Matrix{Int64}:\n 2\n 5\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.middle","page":"API Reference","title":"LightweightStats.middle","text":"middle(x::Real, y::Real)\n\nCompute the middle value between two numbers.\n\nArguments\n\nx::Real: First number\ny::Real: Second number\n\nReturns\n\nThe average of x and y\n\nExamples\n\njulia> using LightweightStats\n\njulia> middle(1, 5)\n3.0\n\njulia> middle(-10, 10)\n0.0\n\njulia> middle(2.5, 3.5)\n3.0\n\n\n\n\n\nmiddle(a::AbstractArray)\n\nCompute the middle of the range of values in array a.\n\nReturns the midpoint between the minimum and maximum values.\n\nArguments\n\na::AbstractArray: Input array\n\nReturns\n\nThe middle value of the range\n\nExamples\n\njulia> using LightweightStats\n\njulia> middle([1, 2, 3, 4, 5])\n3.0\n\njulia> middle([5, 1, 3])  # Order doesn't matter\n3.0\n\njulia> middle([-10, 0, 20])\n5.0\n\nErrors\n\nThrows ArgumentError if array is empty.\n\n\n\n\n\nmiddle(x::Real)\n\nReturn the input value unchanged (identity function for single values).\n\nArguments\n\nx::Real: Input value\n\nReturns\n\nThe same value\n\nExamples\n\njulia> using LightweightStats\n\njulia> middle(42)\n42\n\njulia> middle(3.14)\n3.14\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.var","page":"API Reference","title":"LightweightStats.var","text":"var(A::AbstractArray; corrected=true, mean=nothing, dims=:)\n\nCompute the variance of array A.\n\nArguments\n\nA::AbstractArray: Input array\ncorrected::Bool=true: If true, uses Bessel's correction (divides by n-1)\nmean=nothing: Pre-computed mean (for efficiency). If nothing, computes mean internally\ndims=:: Dimensions along which to compute variance\n\nReturns\n\nScalar variance when dims=:\nArray of variances along specified dimensions otherwise\nReturns NaN for single-element arrays when corrected=true\n\nExamples\n\njulia> using LightweightStats\n\njulia> var([1, 2, 3, 4, 5])\n2.5\n\njulia> var([1, 2, 3, 4, 5]; corrected=false)\n2.0\n\njulia> var([1, 2, 3, 4, 5]; mean=3)\n2.5\n\njulia> var([1 2 3; 4 5 6]; dims=1)\n1×3 Matrix{Float64}:\n 4.5  4.5  4.5\n\nMathematical Definition\n\nFor corrected variance (default):\n\ns² = frac1n-1 sum_i=1^n (x_i - barx)²\n\nFor uncorrected variance:\n\nσ² = frac1n sum_i=1^n (x_i - barx)²\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.std","page":"API Reference","title":"LightweightStats.std","text":"std(A::AbstractArray; corrected=true, mean=nothing, dims=:)\n\nCompute the standard deviation of array A.\n\nStandard deviation is the square root of variance.\n\nArguments\n\nA::AbstractArray: Input array\ncorrected::Bool=true: If true, uses Bessel's correction\nmean=nothing: Pre-computed mean (for efficiency)\ndims=:: Dimensions along which to compute standard deviation\n\nReturns\n\nScalar standard deviation when dims=:\nArray of standard deviations along specified dimensions otherwise\n\nExamples\n\njulia> using LightweightStats\n\njulia> std([1, 2, 3, 4, 5])\n1.5811388300841898\n\njulia> std([1, 2, 3, 4, 5]; corrected=false)\n1.4142135623730951\n\njulia> A = [1 2 3; 4 5 6];\n\njulia> std(A)\n1.8708286933869707\n\njulia> std(A; dims=1)\n1×3 Matrix{Float64}:\n 2.12132  2.12132  2.12132\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.cov","page":"API Reference","title":"LightweightStats.cov","text":"cov(x::AbstractVector, y::AbstractVector; corrected=true)\n\nCompute the covariance between vectors x and y.\n\nSupports complex-valued vectors using internal complex conjugate implementation.\n\nArguments\n\nx::AbstractVector: First vector\ny::AbstractVector: Second vector  \ncorrected::Bool=true: If true, uses Bessel's correction\n\nReturns\n\nScalar covariance value\n\nExamples\n\njulia> using LightweightStats\n\njulia> x = [1.0, 2.0, 3.0, 4.0, 5.0];\n\njulia> y = [2.0, 4.0, 6.0, 8.0, 10.0];\n\njulia> cov(x, y)\n5.0\n\njulia> cov(x, y; corrected=false)\n4.0\n\nErrors\n\nThrows DimensionMismatch if vectors have different lengths.\n\n\n\n\n\ncov(x::AbstractVector; corrected=true)\n\nCompute the variance of vector x (self-covariance).\n\nArguments\n\nx::AbstractVector: Input vector\ncorrected::Bool=true: If true, uses Bessel's correction\n\nReturns\n\nVariance of the vector\n\nExamples\n\njulia> using LightweightStats\n\njulia> cov([1, 2, 3, 4, 5])\n2.5\n\n\n\n\n\ncov(X::AbstractMatrix; dims=1, corrected=true)\n\nCompute the covariance matrix of X.\n\nSupports complex-valued matrices using internal complex conjugate implementation. Uses broadcasting for better performance.\n\nArguments\n\nX::AbstractMatrix: Data matrix\ndims::Int=1: Dimension along which variables are organized\ndims=1: Each column is a variable (default)\ndims=2: Each row is a variable\ncorrected::Bool=true: If true, uses Bessel's correction\n\nReturns\n\nCovariance matrix\n\nExamples\n\njulia> using LightweightStats\n\njulia> X = [1 2; 3 4; 5 6]\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n\njulia> cov(X; dims=1)\n2×2 Matrix{Float64}:\n 4.0  4.0\n 4.0  4.0\n\njulia> cov(X; dims=2)\n3×3 Matrix{Float64}:\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n 0.5  0.5  0.5\n\nErrors\n\nThrows ArgumentError if dims is not 1 or 2.\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.cor","page":"API Reference","title":"LightweightStats.cor","text":"cor(x::AbstractVector, y::AbstractVector)\n\nCompute the Pearson correlation coefficient between vectors x and y.\n\nThe correlation coefficient measures the linear relationship between two variables, ranging from -1 (perfect negative correlation) to 1 (perfect positive correlation).\n\nArguments\n\nx::AbstractVector: First vector\ny::AbstractVector: Second vector\n\nReturns\n\nCorrelation coefficient in range [-1, 1], or NaN if either vector has zero variance\n\nExamples\n\njulia> using LightweightStats\n\njulia> x = [1.0, 2.0, 3.0, 4.0, 5.0];\n\njulia> y = [2.0, 4.0, 6.0, 8.0, 10.0];\n\njulia> cor(x, y)  # Perfect positive correlation\n0.9999999999999998\n\njulia> cor(x, -y)  # Perfect negative correlation\n-0.9999999999999998\n\njulia> cor(x, [1, 1, 1, 1, 1])  # No variance in y\nNaN\n\nMathematical Definition\n\nr = fractextcov(x y)sigma_x sigma_y\n\nErrors\n\nThrows DimensionMismatch if vectors have different lengths.\n\n\n\n\n\ncor(X::AbstractMatrix; dims=1)\n\nCompute the correlation matrix of X.\n\nUses broadcasting for better performance.\n\nArguments\n\nX::AbstractMatrix: Data matrix\ndims::Int=1: Dimension along which variables are organized\ndims=1: Each column is a variable (default)\ndims=2: Each row is a variable\n\nReturns\n\nCorrelation matrix where diagonal elements are 1 (or NaN for zero-variance variables)\n\nExamples\n\njulia> using LightweightStats\n\njulia> X = [1 2; 3 4; 5 6]\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n\njulia> cor(X; dims=1)\n2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n\njulia> cor([1 2 3; 1 2 3]; dims=2)  # Identical rows\n2×2 Matrix{Float64}:\n 1.0  1.0\n 1.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#LightweightStats.quantile","page":"API Reference","title":"LightweightStats.quantile","text":"quantile(v::Vector, p::Real)\n\nCompute the p-th quantile of vector v.\n\nUses linear interpolation between sorted values for non-exact quantile positions.\n\nNote: This function is restricted to Vector type for performance reasons as it uses scalar indexing.\n\nArguments\n\nv::Vector: Input vector\np::Real: Quantile value in range [0, 1]\n\nReturns\n\nThe p-th quantile value\n\nExamples\n\njulia> using LightweightStats\n\njulia> v = [1, 2, 3, 4, 5];\n\njulia> quantile(v, 0.0)  # Minimum\n1\n\njulia> quantile(v, 0.25)  # First quartile\n2.0\n\njulia> quantile(v, 0.5)  # Median\n3.0\n\njulia> quantile(v, 0.75)  # Third quartile\n4.0\n\njulia> quantile(v, 1.0)  # Maximum\n5\n\nErrors\n\nThrows ArgumentError if p is not in [0, 1]\nThrows ArgumentError if vector is empty\n\n\n\n\n\nquantile(v::Vector, p::AbstractVector)\n\nCompute multiple quantiles of vector v.\n\nNote: This function is restricted to Vector type for performance reasons as it uses scalar indexing.\n\nArguments\n\nv::Vector: Input vector\np::AbstractVector: Vector of quantile values in range [0, 1]\n\nReturns\n\nVector of quantile values corresponding to each p\n\nExamples\n\njulia> using LightweightStats\n\njulia> v = [1, 2, 3, 4, 5];\n\njulia> quantile(v, [0.25, 0.5, 0.75])  # Quartiles\n3-element Vector{Float64}:\n 2.0\n 3.0\n 4.0\n\njulia> quantile(v, 0:0.25:1)  # All quartiles including extremes\n5-element Vector{Real}:\n 1\n 2.0\n 3.0\n 4.0\n 5\n\n\n\n\n\n","category":"function"},{"location":"#LightweightStats.jl","page":"Home","title":"LightweightStats.jl","text":"A lightweight Julia package providing basic statistical functions with minimal dependencies.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"LightweightStats.jl is designed as a lower-dependency alternative to Statistics.jl, providing essential statistical functions without pulling in additional dependencies. This makes it ideal for projects that need basic statistical operations but want to minimize their dependency footprint.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"LightweightStats\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using LightweightStats\n\n# Calculate mean\nx = [1, 2, 3, 4, 5]\nmean(x)  # Returns 3.0\n\n# Calculate median\nmedian(x)  # Returns 3\n\n# Calculate standard deviation\nstd(x)  # Returns ~1.58\n\n# Calculate correlation\ny = [2, 4, 6, 8, 10]\ncor(x, y)  # Returns 1.0 (perfect correlation)","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Basic descriptive statistics: mean, median, middle\nDispersion measures: variance (var), standard deviation (std)\nCorrelation and covariance: cor, cov\nQuantiles: quantile function for computing percentiles\nDimension-aware operations: Most functions support the dims keyword for operations along specific dimensions\nType stability: Functions maintain type stability where appropriate\nZero dependencies: Only requires Julia standard library","category":"section"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"#Central-Tendency","page":"Home","title":"Central Tendency","text":"mean(x) - Arithmetic mean\nmean(f, x) - Mean of f applied to elements\nmedian(x) - Median value\nmiddle(x) - Middle of the range (min + max) / 2","category":"section"},{"location":"#Dispersion","page":"Home","title":"Dispersion","text":"var(x; corrected=true) - Variance\nstd(x; corrected=true) - Standard deviation","category":"section"},{"location":"#Correlation-and-Covariance","page":"Home","title":"Correlation and Covariance","text":"cov(x, y; corrected=true) - Covariance between vectors\ncov(X; dims=1, corrected=true) - Covariance matrix\ncor(x, y) - Correlation between vectors\ncor(X; dims=1) - Correlation matrix","category":"section"},{"location":"#Quantiles","page":"Home","title":"Quantiles","text":"quantile(v, p) - Compute the p-th quantile\nquantile(v, ps) - Compute multiple quantiles","category":"section"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"using LightweightStats\n\n# Working with arrays\ndata = randn(100)\nprintln(\"Mean: \", mean(data))\nprintln(\"Median: \", median(data))\nprintln(\"Std Dev: \", std(data))\n\n# Working with matrices\nX = randn(10, 3)\nprintln(\"Column means: \", mean(X; dims=1))\nprintln(\"Row means: \", mean(X; dims=2))\n\n# Correlation matrix\nC = cor(X; dims=1)\nprintln(\"Correlation matrix: \", C)\n\n# Quantiles\nq = quantile(data, [0.25, 0.5, 0.75])\nprintln(\"Quartiles: \", q)","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"LightweightStats.jl aims to provide efficient implementations while maintaining simplicity and readability. The implementations are based on the algorithms used in Statistics.jl but without the additional dependency overhead.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Contributions are welcome! Please feel free to submit a Pull Request.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License.","category":"section"}]
}
